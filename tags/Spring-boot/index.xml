<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Spring-boot on Sanoon</title><link>https://sanoon.me/tags/Spring-boot/</link><description>Recent content in Spring-boot on Sanoon</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 31 Mar 2021 11:45:48 +0800</lastBuildDate><atom:link href="https://sanoon.me/tags/Spring-boot/index.xml" rel="self" type="application/rss+xml"/><item><title>SpringBoot 处理 404 异常返回 JSON 格式数据</title><link>https://sanoon.me/posts/SpringBoot%E5%A4%84%E7%90%86404%E5%BC%82%E5%B8%B8%E8%BF%94%E5%9B%9EJSON%E6%A0%BC%E5%BC%8F%E6%95%B0%E6%8D%AE/</link><pubDate>Wed, 31 Mar 2021 11:45:48 +0800</pubDate><guid>https://sanoon.me/posts/SpringBoot%E5%A4%84%E7%90%86404%E5%BC%82%E5%B8%B8%E8%BF%94%E5%9B%9EJSON%E6%A0%BC%E5%BC%8F%E6%95%B0%E6%8D%AE/</guid><description>Spring Boot 默认对 404 异常处理会重定向到 /error 进行处理，现在流行前后端分离开发，后端基本上不配置静态资源，前后端交互使用 XML 或者 JSON 格式的报文，本文就以返回 JSON 为例，来处理 404 异常。 接上一节Spring Boot 初体验，当我们访问</description></item><item><title>Spring Boot 2 初体验</title><link>https://sanoon.me/posts/SpringBoot2%E5%88%9D%E4%BD%93%E9%AA%8C/</link><pubDate>Wed, 31 Mar 2021 10:24:39 +0800</pubDate><guid>https://sanoon.me/posts/SpringBoot2%E5%88%9D%E4%BD%93%E9%AA%8C/</guid><description>Spring Boot 是一套开箱即用，基于少量的配置和代码快速搭建出一个完整的应用程序的开发框架。下面我们来快速搭建一个工程。 新建 Maven 工程，结构如下 ├─src │ ├─main │ │ ├─java │ │ │ └─com │ │ │ └─lem</description></item><item><title>Spring-boot 集成 Kafka</title><link>https://sanoon.me/posts/Spring-boot-%E9%9B%86%E6%88%90-Kafka/</link><pubDate>Sat, 16 May 2020 23:24:13 +0800</pubDate><guid>https://sanoon.me/posts/Spring-boot-%E9%9B%86%E6%88%90-Kafka/</guid><description>POM 引入 Spring-boot-kafka &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.kafka&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-kafka&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.1.1.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 创建启动类 @SpringBootApplication public class KafkaApplication { public static void main(String[] args) { SpringApplication.run(KafkaApplication.class, args); } } 创建生产者配置类 @Configuration public class ProducerConfiguration { public ProducerConfiguration() { } @Bean public Map&amp;lt;String, Object&amp;gt; producerConfigs() { HashMap&amp;lt;String, Object&amp;gt; props = new HashMap&amp;lt;&amp;gt;(); props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, &amp;quot;localhost:9092&amp;quot;); props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, IntegerSerializer.class); props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class); props.put(ProducerConfig.MAX_BLOCK_MS_CONFIG, 5000); return props; } @Bean public ProducerFactory&amp;lt;String, String&amp;gt; producerFactory() { return new DefaultKafkaProducerFactory&amp;lt;&amp;gt;(producerConfigs()); } @Bean public KafkaTemplate&amp;lt;String, String&amp;gt; kafkaTemplate() { return new KafkaTemplate&amp;lt;&amp;gt;(producerFactory()); } @Bean public Producer sender() { return new Producer(); } } 创</description></item></channel></rss>